#!/usr/bin/env python

import os
import re

# не требуется установки отдельного пакета для SQLite3 при версии питона выше 2.5
#   ДБ/таблица профилей:  id   |  profile
#    каждому профилю соответствует своя ДБ/таблица данных db_ProfileName, 
#    чтобы в случае краша просто удалить файл БД, а остальные профили сохранились
#   ДБ/таблица данных:  id   |  path    |   size    |   last_edited_date-time   |   selected_date-time

# '[1]', "создан каталог баз данных"
# '[2]', "ошибка создания каталога баз данных"
# '[3]', "создана база данных", f"{args.profile}.db"
# '[4]', "недопустимые символы в имени профиля (разрешены: A-Z,a-z,0-9,-,_)

import argparse
import sys

from f_h import Version
import f_modes

#!!! from h import Profile - пока даже тут не используется и если дальше так - то и следующую строку удалить
Profile = "default"   # каждый профиль является своим набором файлов, пересечения возможны

epilog_txt = """  Примеры использования:
                ffdta -m list
                ffdta -m create !!!            
                ffdta -m use !!!
                ffdta -m create MyProfile  !!!
                ffdta --mode use MyProfile !!!
                ffdta -m delete MyProfile
            wishes and suggestions: fynjy-tox@ya.ru""" #!!! тут передача файла ещё должна быть в случае create
                                                    #, хорошо бы сделать ещё с передачей из команды после |
                                                    # в случае use указать с какой даты, количество файлов (дефаулт - всё начиная с последней не отданой)
if sys.version_info < (2, 5):
    epilog_txt += f'\n! Вы пользуетесь Python версии {sys.version}, если нет возможности установить версию пакета 2.5, или лучше, то требуется хотя бы установить пакет sqlite3 для работоспособности базовых функций !'

parser = argparse.ArgumentParser(
    prog='ffdta',
    description=f"""Bременной архив (Date-time file archive) v{Version}',
                    Используется в сочетании с другими программами для не срочного копирования большого числа файлов
                    Программа создаёт таблицу соответствий времени последнего изменения файлов,
                    Отдаёт ссылки на N самых старых файлов, которые ещё не отдавались (либо файлов, изменённых после ДАТА-ВРЕМЯ).""",
    formatter_class=argparse.RawDescriptionHelpFormatter,
    epilog=epilog_txt
)

parser.add_argument ('-m', '--mode', choices=['create', 'delete', 'use', 'list'],                    
                        help="""Указывает, что надо сделать с архивом. Обязательный параметр.
                                create -f FILES PROFILENAME: создать новый профиль и(или) добавить пути в сущестующий
                                delete PROFILENAME: удалить профиль
                                use PROFILENAME: использовать профиль
                                list: показать список профилей"""
)

# Кргда вся выборка уже была отдана раньше, выводит сообщение до и после что эта выборка была повторно скопирована, 
#   поэтому возможно следует остановить сервис источник и скопировать всё до конца начиная с определённой ДАТЫ-ВРЕМЕНИ
#

# !!!         Список текущих профилей:      это потом вставить в list
# availibleProfiles = [ 'default' ] 
# if os.path.exists('db') & os.path.isdir('db'):
#     for f in os.listdir('db'):
#         availibleProfiles.append(re.sub(r'\.db$', '', f))
# availibleProfiles = set(availibleProfiles)

parser.add_argument ('profile', nargs='?', default='default',                     
                        help="""Имя выбранного профиля.
                                Каждый профиль является своим набором файлов, пересечения возможны.
                                не допускаются пробелы и символы кроме A-Z,a-z,0-9,-,_"""
)

parser.add_argument ('-f', '--files', default=os.path.join(os.getcwd(), '*'),                     
                        help='' # не забыть проверку что только с креэйт
)

parser.add_argument ('-d', '--datetime',                      
                        help='' # не забыть проверку что только с use
)

parser.add_argument ('-n', '--n',                     
                        help='' # не забыть проверку что только с use
)

parser.add_argument ('-c', '--check',                     
                        help='' # не забыть проверку что только с use
)

#-----------------

parser.set_defaults(func=f_modes.help)
args = parser.parse_args()

if not args.mode:           # not vars(args):
    parser.print_usage()
else:
    # centos7 использует максимум python v3.5, поэтому ещё не знакома с кейс-логикой
    # match args.mode:
    #     case 'use':
    #         parser.set_defaults(func=f_modes.use)
    #     case 'list':
    #         parser.set_defaults(func=f_modes.list)
    #     case 'create':
    #         parser.set_defaults(func=f_modes.use)
    #     case 'delete':
    #         parser.set_defaults(func=f_modes.list)
    #     case _:
    #         parser.set_defaults(func=f_modes.help)    

    # попроовал использовать структуру и селектор f_modes.f_swich, но там всегда вызывается последний параметр

    try:
        if args.mode == 'use': 
            parser.set_defaults(func=f_modes.use)
        elif args.mode == 'list':
            parser.set_defaults(func=f_modes.list)
        elif args.mode == 'create':
            parser.set_defaults(func=f_modes.create)
        elif args.mode == 'delete':
            parser.set_defaults(func=f_modes.delete)
        else: 
            parser.set_defaults(func=f_modes.help)      
        
        # modes_dict = {
        #     'use': parser.set_defaults(func=f_modes.use),
        #     'list': parser.set_defaults(func=f_modes.list),
        #     'create': parser.set_defaults(func=f_modes.create),
        #     'delete': parser.set_defaults(func=f_modes.delete)
        # }
        #    
        # func = f_modes.f_swich(modes_dict, args.mode, f_modes.help)

        args = parser.parse_args()
        args.func(args)

    except AttributeError:
        parser.print_help()
        parser.exit()




#----------------

#if __name__ == '__main__':
